### types.rs ###
// types.rs
#[cfg(feature = "bitcoin")]
pub mod bitcoin_transaction_builder;

#[cfg(feature = "evm")]
pub mod evm_transaction_builder;

#[cfg(feature = "near")]
pub mod near_transaction_builder;

#[cfg(feature = "near")]
pub type NEAR = near_transaction_builder::NearTransactionBuilder;

#[cfg(feature = "evm")]
pub type EVM = evm_transaction_builder::EVMTransactionBuilder;

#[cfg(feature = "bitcoin")]
pub type BITCOIN = bitcoin_transaction_builder::BitcoinTransactionBuilder;


### lib.rs ###
// lib.rs
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::{
    env, near, AccountId, Allowance, BorshStorageKey, PanicOnDefault, Promise, PublicKey,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

pub mod near;

pub mod active_trial;
pub mod internal;
pub mod models;
pub mod transaction_builder;
pub mod trial_management;

pub use models::*;
pub use near::*;

#[near(contract_state, serializers = [borsh])]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub trial_data_by_id: LookupMap<TrialId, TrialData>,
    pub key_usage_by_pk: LookupMap<PublicKey, KeyUsage>,
    pub admin_account: AccountId,
    pub mpc_contract: AccountId,
    pub trial_nonce: TrialId,
}

#[near]
impl Contract {
    #[init]
    pub fn new(admin_account: AccountId, mpc_contract: AccountId) -> Self {
        Self {
            trial_data_by_id: LookupMap::new(StorageKeys::TrialDataById),
            key_usage_by_pk: LookupMap::new(StorageKeys::KeyUsageByPK),
            admin_account,
            mpc_contract,
            trial_nonce: 0,
        }
    }
}


### internal.rs ###
// internal.rs
use crate::*;

#[near]
impl Contract {
    pub(crate) fn adjust_deposit(&self, initial_storage: u64, final_storage: u64) {
        // Measure the storage difference
        let storage_used = final_storage as i64 - initial_storage as i64;
        let storage_byte_cost = env::storage_byte_cost();

        // If more storage was used (storage_used is positive), calculate the required deposit
        if storage_used > 0 {
            let required_deposit = storage_byte_cost
                .checked_mul(storage_used as u128)
                .expect("Overflow");
            let attached_deposit = env::attached_deposit();

            assert!(
                attached_deposit >= required_deposit,
                "Insufficient deposit: required {} yoctoNEAR",
                required_deposit
            );

            // Refund any excess deposit
            let refund = attached_deposit.checked_sub(required_deposit);
            if let Some(refund) = refund {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }
        // If storage was freed up (storage_used is negative), calculate the refund
        else if storage_used < 0 {
            let refund_amount = storage_byte_cost
                .checked_mul((-storage_used) as u128)
                .expect("Overflow");

            // Transfer the refund for freed storage
            Promise::new(env::predecessor_account_id()).transfer(refund_amount);
        }
    }
}


### transaction_builder.rs ###
// transaction_builder.rs
pub trait TxBuilder<T> {
    fn build(&self) -> T;
}

pub struct TransactionBuilder;

impl TransactionBuilder {
    #[allow(clippy::new_ret_no_self)]
    pub fn new<T>() -> T
    where
        T: Default,
    {
        T::default()
    }
}


### trial_management/delete_trial.rs ###
use crate::*;

#[near]
impl Contract {
    /// Deletes a trial. Only callable by the creator.
    pub fn delete_trial(&mut self, trial_id: TrialId) {
        let trial_data = self
            .trial_data_by_id
            .get(&trial_id)
            .expect("Trial ID does not exist");

        // Only the creator can delete the trial
        assert_eq!(
            env::predecessor_account_id(),
            trial_data.creator_account_id,
            "Only the trial creator can delete the trial"
        );

        let initial_storage = env::storage_usage();
        self.trial_data_by_id.remove(&trial_id);

        self.adjust_deposit(initial_storage, env::storage_usage());
    }

    /// Deletes unused trials and returns funds to the creator.
    pub fn delete_unused_trial(&mut self, trial_id: TrialId, derivation_path: String) {
        let trial_data = self
            .trial_data_by_id
            .get(&trial_id)
            .expect("Trial ID does not exist");

        // Only the creator can delete the trial
        assert_eq!(
            env::predecessor_account_id(),
            trial_data.creator_account_id,
            "Only the trial creator can delete the trial"
        );

        // Prepare the transaction to delete the trial account and transfer funds back
        let delete_account_action = Action::DeleteAccount(DeleteAccountAction {
            beneficiary_id: trial_data.creator_account_id.clone(),
        });

        let transaction = NearTransaction {
            signer_id: env::current_account_id(),
            signer_public_key: env::signer_account_pk(),
            nonce: U64(0),
            receiver_id: env::current_account_id(),
            block_hash: BlockHash(env::block_hash().0),
            actions: vec![delete_account_action],
        };

        let payload = borsh::to_vec(&transaction).unwrap();

        // Call the MPC contract to sign the transaction
        let sign_request = SignRequest {
            payload: payload.clone(),
            path: derivation_path.clone(),
            key_version: 0, // Update as needed
            chain_id: trial_data.chain_id,
        };

        Promise::new(self.mpc_contract.clone())
            .function_call(
                "sign".to_string(),
                near_sdk::serde_json::to_vec(&sign_request).unwrap(),
                0,
                env::prepaid_gas() - env::used_gas(),
            )
            .then(Promise::new(env::current_account_id()).function_call(
                "on_delete_trial".to_string(),
                near_sdk::serde_json::to_vec(&trial_id).unwrap(),
                0,
                env::prepaid_gas() - env::used_gas(),
            ));
    }

    /// Callback after trial deletion.
    #[private]
    pub fn on_delete_trial(&mut self, trial_id: TrialId) {
        self.trial_data_by_id.remove(&trial_id);
    }
}


### trial_management/create_trial.rs ###
// trial_management/create_trial.rs
use crate::*;

#[near]
impl Contract {
    /// Creates a new trial with specified parameters.
    #[payable]
    pub fn create_trial(
        &mut self,
        allowed_methods: Vec<String>,
        allowed_contracts: Vec<AccountId>,
        max_gas: Option<u64>,
        max_deposit: Option<U128>,
        usage_constraints: Option<UsageConstraints>,
        interaction_limits: Option<InteractionLimits>,
        exit_conditions: Option<ExitConditions>,
        expiration_time: Option<u64>,
        chain_id: u64,
    ) -> TrialId {
        let creator_account_id = env::predecessor_account_id();

        let trial_data = TrialData {
            allowed_methods,
            allowed_contracts,
            max_gas,
            max_deposit,
            usage_constraints,
            interaction_limits,
            exit_conditions,
            expiration_time,
            chain_id,
            creator_account_id,
        };

        let initial_storage = env::storage_usage();

        self.trial_nonce += 1;
        let trial_id = self.trial_nonce;

        self.trial_data_by_id.insert(&trial_id, &trial_data);

        self.adjust_deposit(initial_storage, env::storage_usage());

        trial_id
    }
}


### trial_management/add_keys.rs ###
// trial_management/add_keys.rs
use crate::*;

#[near]
impl Contract {
    /// Associates public keys with a trial account in batch.
    #[payable]
    pub fn add_trial_keys(&mut self, public_keys: Vec<PublicKey>, trial_id: TrialId) {
        let trial_data = self
            .trial_data_by_id
            .get(&trial_id)
            .expect("Trial ID does not exist");

        // Only the creator can add keys to their trial
        assert_eq!(
            env::predecessor_account_id(),
            trial_data.creator_account_id,
            "Only the trial creator can add keys"
        );

        let initial_storage = env::storage_usage();

        for public_key in public_keys.iter() {
            let key_usage = KeyUsage {
                trial_id,
                usage_stats: UsageStats::default(),
            };

            self.key_usage_by_pk.insert(public_key, &key_usage);

            // Add the access key to the contract with limited permissions
            Promise::new(env::current_account_id()).add_access_key_allowance(
                public_key.clone(),
                Allowance::Unlimited, // Set allowance as needed
                env::current_account_id(),
                TRIAL_ACCESS_KEY_METHODS.to_string(),
            );
        }

        self.adjust_deposit(initial_storage, env::storage_usage());
    }
}


### trial_management/mod.rs ###
pub mod add_keys;
pub mod create_trial;
pub mod delete_trial;


### models/constants.rs ###
/// EIP-1559 transaction type
pub const EIP_1559_TYPE: u8 = 0x02;
/// Length of an Ed25519 public key
pub const ED25519_PUBLIC_KEY_LENGTH: usize = 32;
/// Length of a secp256k1 public key
pub const SECP256K1_PUBLIC_KEY_LENGTH: usize = 64;
/// Length of a secp256k1 signature
pub const SECP256K1_SIGNATURE_LENGTH: usize = 65;
/// Size of a single component of an Ed25519 signature.
pub const COMPONENT_SIZE: usize = 32;
/// Length of an Ed25519 signature
pub const ED25519_SIGNATURE_LENGTH: usize = COMPONENT_SIZE * 2;

// Access key methods name for trial accounts
pub const TRIAL_ACCESS_KEY_METHODS: &str = "create_account,call_function,exit_trial";


### models/trials.rs ###
use crate::*;

/// Contains data about a trial, such as allowed methods, contracts, limits, etc.
#[derive(Clone)]
#[near(serializers = [json, borsh])]
pub struct TrialData {
    pub allowed_methods: Vec<String>,
    pub allowed_contracts: Vec<AccountId>,
    pub max_gas: Option<u64>,
    pub max_deposit: Option<U128>,
    pub usage_constraints: Option<UsageConstraints>,
    pub interaction_limits: Option<InteractionLimits>,
    pub exit_conditions: Option<ExitConditions>,
    pub expiration_time: Option<u64>, // timestamp in nanoseconds
    pub chain_id: u64,
    pub creator_account_id: AccountId,
}

/// Specifies usage constraints like max contracts and methods.
#[derive(Clone)]
#[near(serializers = [json, borsh])]
pub struct UsageConstraints {
    pub max_contracts: Option<u64>,
    pub max_methods: Option<u64>,
}

/// Defines interaction limits for trial accounts.
#[derive(Clone)]
#[near(serializers = [json, borsh])]
pub struct InteractionLimits {
    pub max_interactions_per_day: Option<u64>,
    pub total_interactions: Option<u64>,
}

/// Specifies exit conditions for trial accounts.
#[derive(Clone)]
#[near(serializers = [json, borsh])]
pub struct ExitConditions {
    pub transaction_limit: Option<u64>,
    pub success_condition: Option<FunctionSuccessCondition>,
    pub time_limit: Option<u64>, // timestamp in nanoseconds
}

/// Tracks usage statistics for trial accounts.
#[derive(Clone)]
#[near(serializers = [json, borsh])]
pub struct UsageStats {
    pub interactions_per_day: HashMap<u64, u64>, // Day timestamp to interaction count
    pub total_interactions: u64,
    pub methods_called: HashMap<String, u64>, // method_name to count
    pub contracts_called: HashMap<AccountId, u64>, // contract_id to count
    pub gas_used: u64,
    pub deposit_used: U128,
}
// Implement default for UsageStats
impl Default for UsageStats {
    fn default() -> Self {
        Self {
            interactions_per_day: HashMap::new(),
            total_interactions: 0,
            methods_called: HashMap::new(),
            contracts_called: HashMap::new(),
            gas_used: 0,
            deposit_used: U128(0),
        }
    }
}

/// Associates a public key with its usage stats and trial ID.
#[derive(Clone)]
#[near(serializers = [json, borsh])]
pub struct KeyUsage {
    pub trial_id: TrialId,
    pub usage_stats: UsageStats,
}

/// Represents a function success condition based on output.
#[derive(Clone)]
#[near(serializers = [json, borsh])]
pub struct FunctionSuccessCondition {
    pub contract_id: AccountId,
    pub method_name: String,
    pub expected_return: String,
}


### models/mod.rs ###
pub mod constants;
pub mod contract;
pub mod mpc;
pub mod trials;

pub use constants::*;
pub use contract::*;
pub use mpc::*;
pub use trials::*;


### models/contract.rs ###
use crate::*;

/// Storage keys for the contract's collections.
#[near]
#[derive(BorshStorageKey)]
pub enum StorageKeys {
    TrialDataById,
    KeyUsageByPK,
}

pub type TrialId = u32;


### models/mpc.rs ###
use crate::*;

// models.rs or types.rs
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SignRequest {
    pub payload: Vec<u8>,
    pub path: String, // Derivation path
    pub key_version: u32,
    pub chain_id: u64,
}


### active_trial/usage_tracking.rs ###
// usage_tracking.rs
use crate::*;

#[near]
impl Contract {
    /// Internal method to assert if a key is allowed to perform an action.
    fn assert_action_allowed(
        &mut self,
        method_name: &str,
        contract_id: &AccountId,
        gas_attached: NearGas,
        deposit_attached: U128,
    ) -> (TrialData, KeyUsage) {
        let public_key = env::signer_account_pk();

        // Fetch KeyUsage
        let mut key_usage = self
            .key_usage_by_pk
            .get(&public_key)
            .expect("Access denied");

        // Fetch TrialData
        let trial_data = self
            .trial_data_by_id
            .get(&key_usage.trial_id)
            .expect("Trial data not found");

        // Check expiration time
        if let Some(expiration_time) = trial_data.expiration_time {
            assert!(
                env::block_timestamp() < expiration_time,
                "Trial period has expired"
            );
        }

        // Check allowed methods
        if !trial_data
            .allowed_methods
            .contains(&method_name.to_string())
        {
            env::panic_str("Method not allowed");
        }

        // Check allowed contracts
        if !trial_data.allowed_contracts.contains(contract_id) {
            env::panic_str("Contract not allowed");
        }

        // Check gas and deposit limits
        if let Some(max_gas) = trial_data.max_gas {
            assert!(
                gas_attached.0 <= max_gas,
                "Attached gas exceeds maximum allowed"
            );
        }
        if let Some(max_deposit) = trial_data.max_deposit {
            assert!(
                deposit_attached.0 <= max_deposit.0,
                "Attached deposit exceeds maximum allowed"
            );
        }

        // Update usage statistics
        key_usage.usage_stats.total_interactions += 1;
        key_usage.usage_stats.gas_used += gas_attached.0;
        key_usage.usage_stats.deposit_used.0 += deposit_attached.0;

        // Update the key usage
        self.key_usage_by_pk.insert(&public_key, &key_usage);

        (trial_data, key_usage)
    }

    /// Public method to perform an action after all validations.
    pub fn perform_action(
        &mut self,
        contract_id: AccountId,
        method_name: String,
        args: Vec<u8>,
        gas: NearGas,
        deposit: U128,
    ) {
        let (trial_data, key_usage) =
            self.assert_action_allowed(&method_name, &contract_id, gas, deposit);

        // Check exit conditions if any
        if let Some(exit_conditions) = &trial_data.exit_conditions {
            // Check transaction limit
            if let Some(transaction_limit) = exit_conditions.transaction_limit {
                if key_usage.usage_stats.total_interactions > transaction_limit {
                    env::panic_str("Transaction limit reached");
                }
            }
            // Additional exit conditions can be checked here
        }

        // All checks passed, proceed to call the MPC contract
        self.call_mpc_contract(
            contract_id,
            method_name,
            args,
            gas,
            deposit,
            trial_data.chain_id,
        );
    }

    /// Internal method to call the MPC contract.
    fn call_mpc_contract(
        &self,
        contract_id: AccountId,
        method_name: String,
        args: Vec<u8>,
        gas: NearGas,
        deposit: U128,
        chain_id: u64,
    ) {
        let mpc_contract = self.mpc_contract.clone();

        // Build the NEAR transaction
        let tx = TransactionBuilder::new::<NEAR>()
            .signer_id(env::current_account_id())
            .signer_public_key(env::signer_account_pk().into())
            .nonce(0) // Replace with appropriate nonce
            .receiver_id(contract_id.clone())
            .block_hash(env::block_hash().into())
            .actions(vec![Action::FunctionCall(Box::new(FunctionCallAction {
                method_name: method_name.clone(),
                args: args.clone(),
                gas: gas.into(),
                deposit: deposit.into(),
            }))])
            .build();

        let payload = tx.build_for_signing();

        // Prepare the sign request
        let sign_request = SignRequest {
            payload,
            path: method_name.clone(),
            key_version: 0, // Assuming version 0 for simplicity
            chain_id,
        };

        // Call the MPC contract to get a signature
        Promise::new(mpc_contract).function_call(
            "sign".to_string(),
            near_sdk::serde_json::to_vec(&sign_request).unwrap(),
            0,
            env::prepaid_gas() - env::used_gas(),
        );
    }
}


### active_trial/exit_trial.rs ###
// active_trial/exit_trial.rs
use crate::*;
use near_sdk::{env, near_bindgen, Promise};

#[near]
impl Contract {
    /// Allows a trial user to exit the trial, adding a full access key to their account.
    pub fn exit_trial(&mut self, public_key: PublicKey, derivation_path: String) {
        let signer_pk = env::signer_account_pk();
        let key_usage = self.key_usage_by_pk.get(&signer_pk).expect("Access denied");

        let trial_data = self
            .trial_data_by_id
            .get(&key_usage.trial_id)
            .expect("Trial data not found");

        // Build the transaction to add a full access key
        let add_key_action = Action::AddKey(Box::new(AddKeyAction {
            public_key: public_key.clone(),
            access_key: AccessKey {
                nonce: U64(0),
                permission: AccessKeyPermission::FullAccess,
            },
        }));

        let tx = TransactionBuilder::new::<NEAR>()
            .signer_id(env::current_account_id())
            .signer_public_key(signer_pk.into())
            .nonce(0) // Replace with appropriate nonce
            .receiver_id(env::current_account_id())
            .block_hash(env::block_hash().into())
            .actions(vec![add_key_action])
            .build();

        let payload = tx.build_for_signing();

        // Call the MPC contract to sign the transaction
        let sign_request = SignRequest {
            payload,
            path: derivation_path.clone(),
            key_version: 0, // Update as needed
            chain_id: trial_data.chain_id,
        };

        Promise::new(self.mpc_contract.clone()).function_call(
            "sign".to_string(),
            near_sdk::serde_json::to_vec(&sign_request).unwrap(),
            0,
            env::prepaid_gas() - env::used_gas(),
        );
    }
}


### active_trial/mod.rs ###
pub mod exit_trial;
pub mod usage_tracking;


### near/near_transaction.rs ###
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{borsh, AccountId};

use super::types::{Action, BlockHash, PublicKey, Signature, U64};

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NearTransaction {
    /// An account on which behalf transaction is signed
    pub signer_id: AccountId,
    /// A public key of the access key which was used to sign an account.
    /// Access key holds permissions for calling certain kinds of actions.
    pub signer_public_key: PublicKey,
    /// Nonce is used to determine order of transaction in the pool.
    /// It increments for a combination of `signer_id` and `public_key`
    pub nonce: U64,
    /// Receiver account for this transaction
    pub receiver_id: AccountId,
    /// The hash of the block in the blockchain on top of which the given transaction is valid
    pub block_hash: BlockHash,
    /// A list of actions to be applied
    pub actions: Vec<Action>,
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct SignedTransaction {
    pub transaction: NearTransaction,
    pub signature: Signature,
}

impl NearTransaction {
    pub fn build_for_signing(&self) -> Vec<u8> {
        borsh::to_vec(self).expect("failed to serialize NEAR transaction")
    }

    pub fn build_with_signature(&self, signature: Signature) -> Vec<u8> {
        let signed_tx = SignedTransaction {
            transaction: self.clone(),
            signature,
        };
        borsh::to_vec(&signed_tx).expect("failed to serialize NEAR transaction")
    }

    pub fn from_json(json: &str) -> Result<Self, near_sdk::serde_json::Error> {
        near_sdk::serde_json::from_str(json)
    }
}


### near/near_transaction_builder.rs ###
// near/near_transaction_builder.rs
use super::{
    near_transaction::NearTransaction,
    types::{Action, BlockHash, PublicKey, U64},
};
use crate::transaction_builder::TxBuilder;

#[derive(Default)]
pub struct NearTransactionBuilder {
    pub signer_id: Option<String>,
    pub signer_public_key: Option<PublicKey>,
    pub nonce: Option<u64>,
    pub receiver_id: Option<String>,
    pub block_hash: Option<BlockHash>,
    pub actions: Option<Vec<Action>>,
}

impl TxBuilder<NearTransaction> for NearTransactionBuilder {
    fn build(&self) -> NearTransaction {
        NearTransaction {
            signer_id: self
                .signer_id
                .clone()
                .expect("Missing signer ID")
                .parse()
                .unwrap(),
            signer_public_key: self
                .signer_public_key
                .clone()
                .expect("Missing signer public key"),
            nonce: U64(self.nonce.expect("Missing nonce")),
            receiver_id: self
                .receiver_id
                .clone()
                .expect("Missing receiver ID")
                .parse()
                .unwrap(),
            block_hash: self.block_hash.clone().expect("Missing block hash"),
            actions: self.actions.clone().expect("Missing actions"),
        }
    }
}

impl NearTransactionBuilder {
    pub fn signer_id(mut self, signer_id: String) -> Self {
        self.signer_id = Some(signer_id);
        self
    }

    pub fn signer_public_key(mut self, signer_public_key: PublicKey) -> Self {
        self.signer_public_key = Some(signer_public_key);
        self
    }

    pub fn nonce(mut self, nonce: u64) -> Self {
        self.nonce = Some(nonce);
        self
    }

    pub fn receiver_id(mut self, receiver_id: String) -> Self {
        self.receiver_id = Some(receiver_id);
        self
    }

    pub fn block_hash(mut self, block_hash: BlockHash) -> Self {
        self.block_hash = Some(block_hash);
        self
    }

    pub fn actions(mut self, actions: Vec<Action>) -> Self {
        self.actions = Some(actions);
        self
    }
}


### near/mod.rs ###
pub mod near_transaction;
pub mod near_transaction_builder;
pub mod types;
pub mod utils;


### near/types/actions.rs ###
use crate::near::types::PublicKey;
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;

use super::{U128, U64};

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    /// Create an (sub)account using a transaction `receiver_id` as an ID for
    /// a new account ID must pass validation rules described here
    /// <http://nomicon.io/Primitives/Account.html>.
    CreateAccount(CreateAccountAction),
    /// Sets a Wasm code to a receiver_id
    DeployContract(DeployContractAction),
    FunctionCall(Box<FunctionCallAction>),
    Transfer(TransferAction),
    Stake(Box<StakeAction>),
    AddKey(Box<AddKeyAction>),
    DeleteKey(Box<DeleteKeyAction>),
    DeleteAccount(DeleteAccountAction),
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct CreateAccountAction {}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct DeployContractAction {
    pub code: Vec<u8>,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct FunctionCallAction {
    pub method_name: String,
    pub args: Vec<u8>,
    pub gas: U64,
    pub deposit: U128,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct TransferAction {
    pub deposit: U128,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct StakeAction {
    /// Amount of tokens to stake.
    pub stake: U128,
    /// Validator key which will be used to sign transactions on behalf of signer_id
    pub public_key: PublicKey,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct AddKeyAction {
    /// A public key which will be associated with an access_key
    pub public_key: PublicKey,
    /// An access key with the permission
    pub access_key: AccessKey,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct AccessKey {
    /// Nonce for this access key, used for tx nonce generation. When access key is created, nonce
    /// is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.
    /// See <https://github.com/near/nearcore/issues/3779> for more details.
    pub nonce: U64,
    /// Defines permissions for this access key.
    pub permission: AccessKeyPermission,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub enum AccessKeyPermission {
    FunctionCall(FunctionCallPermission),
    /// Grants full access to the account.
    /// NOTE: It's used to replace account-level public keys.
    FullAccess,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct FunctionCallPermission {
    pub allowance: Option<U128>,
    pub receiver_id: String,
    pub method_names: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct DeleteKeyAction {
    /// A public key associated with the access_key to be deleted.
    pub public_key: PublicKey,
}

#[derive(Serialize, Deserialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct DeleteAccountAction {
    pub beneficiary_id: AccountId,
}


### near/types/integers.rs ###
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Deserializer, Serialize};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize, Serialize)]
pub struct U64(pub u64);

#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize, Serialize)]
pub struct U128(pub u128);

impl From<u64> for U64 {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl From<u128> for U128 {
    fn from(value: u128) -> Self {
        Self(value)
    }
}

impl<'de> Deserialize<'de> for U64 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct StringOrNumberVisitor;

        impl<'de> serde::de::Visitor<'de> for StringOrNumberVisitor {
            type Value = U64;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str("a string or a number")
            }

            fn visit_str<E>(self, value: &str) -> Result<U64, E>
            where
                E: serde::de::Error,
            {
                value
                    .parse::<u64>()
                    .map(U64)
                    .map_err(serde::de::Error::custom)
            }

            fn visit_u64<E>(self, value: u64) -> Result<U64, E>
            where
                E: serde::de::Error,
            {
                Ok(U64(value))
            }
        }

        deserializer.deserialize_any(StringOrNumberVisitor)
    }
}

impl<'de> Deserialize<'de> for U128 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct StringOrNumberVisitor;

        impl<'de> serde::de::Visitor<'de> for StringOrNumberVisitor {
            type Value = U128;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str("a string or a number 128")
            }

            fn visit_str<E>(self, value: &str) -> Result<U128, E>
            where
                E: serde::de::Error,
            {
                value
                    .parse::<u128>()
                    .map(U128)
                    .map_err(serde::de::Error::custom)
            }

            fn visit_u64<E>(self, value: u64) -> Result<U128, E>
            where
                E: serde::de::Error,
            {
                Ok(U128(value as u128))
            }

            fn visit_u128<E>(self, value: u128) -> Result<U128, E>
            where
                E: serde::de::Error,
            {
                Ok(U128(value))
            }
        }

        deserializer.deserialize_any(StringOrNumberVisitor)
    }
}


### near/types/mod.rs ###
mod actions;
mod block_hash;
mod integers;
mod public_key;
mod signature;

pub use actions::*;
pub use block_hash::*;
pub use integers::*;
pub use public_key::*;
pub use signature::*;


### near/types/signature.rs ###
use borsh::{BorshDeserialize, BorshSerialize};
use bs58;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::fmt::Debug;

use crate::constants::{COMPONENT_SIZE, SECP256K1_SIGNATURE_LENGTH};

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub enum Signature {
    ED25519(ED25519Signature),
    SECP256K1(Secp256K1Signature),
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct ED25519Signature {
    pub r: ComponentBytes,
    pub s: ComponentBytes,
}

/// Size of an `R` or `s` component of an Ed25519 signature when serialized as bytes.
pub type ComponentBytes = [u8; COMPONENT_SIZE];

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct Secp256K1Signature(pub [u8; SECP256K1_SIGNATURE_LENGTH]);

impl Serialize for Signature {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Self::ED25519(sig) => {
                let mut bytes = Vec::with_capacity(COMPONENT_SIZE * 2);
                bytes.extend_from_slice(&sig.r);
                bytes.extend_from_slice(&sig.s);

                let encoded = bs58::encode(&bytes).into_string();
                serializer.serialize_str(&format!("ed25519:{}", encoded))
            }
            Self::SECP256K1(sig) => {
                let encoded = bs58::encode(&sig.0).into_string();
                serializer.serialize_str(&format!("secp256k1:{}", encoded))
            }
        }
    }
}

impl<'de> Deserialize<'de> for Signature {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        let (key_type, sig_data) = s.split_at(
            s.find(':')
                .ok_or_else(|| serde::de::Error::custom("Invalid signature format"))?,
        );
        let sig_data = &sig_data[1..]; // Skip the colon

        match key_type {
            "ed25519" => {
                let bytes = bs58::decode(sig_data)
                    .into_vec()
                    .map_err(serde::de::Error::custom)?;

                let signature = ED25519Signature {
                    r: bytes[0..COMPONENT_SIZE]
                        .try_into()
                        .map_err(serde::de::Error::custom)?,
                    s: bytes[COMPONENT_SIZE..]
                        .try_into()
                        .map_err(serde::de::Error::custom)?,
                };
                Ok(Self::ED25519(signature))
            }
            "secp256k1" => {
                let bytes = bs58::decode(sig_data)
                    .into_vec()
                    .map_err(serde::de::Error::custom)?;

                if bytes.len() != SECP256K1_SIGNATURE_LENGTH {
                    return Err(serde::de::Error::custom(
                        "Invalid SECP256K1 signature length",
                    ));
                }

                let mut array = [0u8; SECP256K1_SIGNATURE_LENGTH];
                array.copy_from_slice(&bytes);
                Ok(Self::SECP256K1(Secp256K1Signature(array)))
            }
            _ => Err(serde::de::Error::custom("Unknown key type")),
        }
    }
}


### near/types/public_key.rs ###
use crate::constants::{ED25519_PUBLIC_KEY_LENGTH, SECP256K1_PUBLIC_KEY_LENGTH};
use crate::near::utils::PublicKeyStrExt;
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Deserializer, Serialize};
use serde::de;
use serde_big_array::BigArray;
use std::io::{Error, Write};

#[derive(Serialize, Deserialize, BorshDeserialize, PartialEq, Eq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Secp256K1PublicKey(#[serde(with = "BigArray")] pub [u8; SECP256K1_PUBLIC_KEY_LENGTH]);

#[derive(Serialize, Deserialize, BorshDeserialize, PartialEq, Eq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ED25519PublicKey(pub [u8; ED25519_PUBLIC_KEY_LENGTH]);

#[derive(Serialize, PartialEq, Eq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum PublicKey {
    /// 256 bit elliptic curve based public-key.
    ED25519(ED25519PublicKey),
    /// 512 bit elliptic curve based public-key used in Bitcoin's public-key cryptography.
    SECP256K1(Secp256K1PublicKey),
}

impl BorshSerialize for PublicKey {
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<(), Error> {
        match self {
            Self::ED25519(public_key) => {
                BorshSerialize::serialize(&0u8, writer)?;
                writer.write_all(&public_key.0)?;
            }
            Self::SECP256K1(public_key) => {
                BorshSerialize::serialize(&1u8, writer)?;
                writer.write_all(&public_key.0)?;
            }
        }
        Ok(())
    }
}

impl BorshDeserialize for PublicKey {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        let key_type = <u8 as BorshDeserialize>::deserialize(buf)?;
        match key_type {
            0 => Ok(Self::ED25519(
                <ED25519PublicKey as BorshDeserialize>::deserialize(buf)?,
            )),
            1 => Ok(Self::SECP256K1(
                <Secp256K1PublicKey as BorshDeserialize>::deserialize(buf)?,
            )),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid public key type",
            )),
        }
    }

    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> std::io::Result<Self> {
        let key_type = u8::deserialize_reader(reader)?;
        match key_type {
            0 => Ok(Self::ED25519(ED25519PublicKey::deserialize_reader(reader)?)),
            1 => Ok(Self::SECP256K1(Secp256K1PublicKey::deserialize_reader(
                reader,
            )?)),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid public key type",
            )),
        }
    }
}

// From implementations for fixed size arrays
impl From<[u8; SECP256K1_PUBLIC_KEY_LENGTH]> for Secp256K1PublicKey {
    fn from(data: [u8; SECP256K1_PUBLIC_KEY_LENGTH]) -> Self {
        Self(data)
    }
}

impl From<[u8; ED25519_PUBLIC_KEY_LENGTH]> for ED25519PublicKey {
    fn from(data: [u8; ED25519_PUBLIC_KEY_LENGTH]) -> Self {
        Self(data)
    }
}

// TryFrom implementations for slices and vectors
impl TryFrom<&[u8]> for PublicKey {
    type Error = String;

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        match value.len() {
            ED25519_PUBLIC_KEY_LENGTH => {
                Ok(Self::ED25519(ED25519PublicKey(value.try_into().unwrap())))
            }
            SECP256K1_PUBLIC_KEY_LENGTH => Ok(Self::SECP256K1(Secp256K1PublicKey(
                value.try_into().unwrap(),
            ))),
            _ => Err("Invalid public key length".to_string()),
        }
    }
}

impl TryFrom<Vec<u8>> for PublicKey {
    type Error = String;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        Self::try_from(value.as_slice())
    }
}

// Serialization
impl<'de> Deserialize<'de> for PublicKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct PublicKeyOrBytes;

        impl<'de> serde::de::Visitor<'de> for PublicKeyOrBytes {
            type Value = PublicKey;

            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("a string or byte array representing a public key")
            }

            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                value.to_public_key().map_err(de::Error::custom)
            }

            fn visit_map<V>(self, mut map: V) -> Result<PublicKey, V::Error>
            where
                V: de::MapAccess<'de>,
            {
                let key = map
                    .next_key::<String>()?
                    .ok_or_else(|| de::Error::missing_field("key type"))?;
                match key.as_str() {
                    "ED25519" => {
                        let bytes: Vec<u8> = map.next_value()?;
                        PublicKey::try_from(bytes.as_slice()).map_err(de::Error::custom)
                    }
                    "SECP256K1" => {
                        let bytes: Vec<u8> = map.next_value()?;
                        PublicKey::try_from(bytes.as_slice()).map_err(de::Error::custom)
                    }
                    _ => Err(de::Error::unknown_field(&key, &["ED25519", "SECP256K1"])),
                }
            }
        }

        deserializer.deserialize_any(PublicKeyOrBytes)
    }
}


### near/types/block_hash.rs ###
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Deserializer, Serialize};
use serde::de;
use serde_big_array::BigArray;

#[derive(Serialize, Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub struct BlockHash(#[serde(with = "BigArray")] pub [u8; 32]);

impl From<[u8; 32]> for BlockHash {
    fn from(data: [u8; 32]) -> Self {
        Self(data)
    }
}

impl<'de> Deserialize<'de> for BlockHash {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct BlockHashOrBytes;

        impl<'de> serde::de::Visitor<'de> for BlockHashOrBytes {
            type Value = BlockHash;

            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("a string or byte array representing a block hash")
            }

            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                let bytes = bs58::decode(value).into_vec().map_err(de::Error::custom)?;
                let array: [u8; 32] = bytes
                    .try_into()
                    .map_err(|_| de::Error::custom("Invalid length"))?;

                Ok(BlockHash(array))
            }

            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: de::SeqAccess<'de>,
            {
                let mut arr = [0u8; 32];
                for (i, elem) in arr.iter_mut().enumerate() {
                    *elem = seq
                        .next_element()?
                        .ok_or_else(|| de::Error::invalid_length(i, &self))?;
                }
                Ok(BlockHash(arr))
            }
        }

        deserializer.deserialize_any(BlockHashOrBytes)
    }
}


### near/utils/signature_utils.rs ###
use crate::{
    constants::{ED25519_SIGNATURE_LENGTH, SECP256K1_SIGNATURE_LENGTH},
    near::types::{ED25519Signature, Secp256K1Signature, Signature},
};
use bs58;
use std::convert::TryInto;

pub trait SignatureStrExt {
    fn to_signature(&self) -> Result<Signature, String>;
    fn to_signature_as_bytes(&self) -> Result<Vec<u8>, String>;
    fn try_ed25519_into_bytes(&self) -> Result<[u8; ED25519_SIGNATURE_LENGTH], String>;
    fn try_secp256k1_into_bytes(&self) -> Result<[u8; SECP256K1_SIGNATURE_LENGTH], String>;
    fn to_ed25519_signature(&self) -> Result<ED25519Signature, String>;
    fn to_secp256k1_signature(&self) -> Result<Secp256K1Signature, String>;
}

impl SignatureStrExt for str {
    fn to_signature(&self) -> Result<Signature, String> {
        let bytes = self.to_signature_as_bytes()?;
        if self.starts_with("ed25519:") {
            Ok(Signature::ED25519(ED25519Signature {
                r: bytes[..32]
                    .try_into()
                    .map_err(|_| "Invalid length for ED25519 signature".to_string())?,
                s: bytes[32..]
                    .try_into()
                    .map_err(|_| "Invalid length for ED25519 signature".to_string())?,
            }))
        } else if self.starts_with("secp256k1:") {
            Ok(Signature::SECP256K1(Secp256K1Signature(
                bytes
                    .try_into()
                    .map_err(|_| "Invalid length for SECP256K1 signature".to_string())?,
            )))
        } else {
            Err("Unknown key type".into())
        }
    }

    fn to_signature_as_bytes(&self) -> Result<Vec<u8>, String> {
        let (key_type, key_data) = self
            .split_once(':')
            .ok_or_else(|| "Invalid key format".to_string())?;

        let bytes = bs58::decode(key_data)
            .into_vec()
            .map_err(|e| format!("Failed to decode base58: {}", e))?;

        match key_type {
            "ed25519" => {
                if bytes.len() == ED25519_SIGNATURE_LENGTH {
                    Ok(bytes)
                } else {
                    Err("ED25519 public key should be 32 bytes long".to_string())
                }
            }
            "secp256k1" => {
                if bytes.len() == SECP256K1_SIGNATURE_LENGTH {
                    Ok(bytes)
                } else {
                    Err("SECP256K1 public key should be 64 bytes long".to_string())
                }
            }
            _ => Err("Unknown key type".into()),
        }
    }

    fn try_ed25519_into_bytes(&self) -> Result<[u8; ED25519_SIGNATURE_LENGTH], String> {
        let bytes = self.to_signature_as_bytes()?;
        if bytes.len() == ED25519_SIGNATURE_LENGTH {
            Ok(bytes.try_into().unwrap())
        } else {
            Err("Invalid length for ED25519 signature".to_string())
        }
    }

    fn try_secp256k1_into_bytes(&self) -> Result<[u8; SECP256K1_SIGNATURE_LENGTH], String> {
        let bytes = self.to_signature_as_bytes()?;
        if bytes.len() == SECP256K1_SIGNATURE_LENGTH {
            Ok(bytes.try_into().unwrap())
        } else {
            Err("Invalid length for SECP256K1 signature".to_string())
        }
    }

    fn to_ed25519_signature(&self) -> Result<ED25519Signature, String> {
        let bytes = self.try_ed25519_into_bytes()?;
        Ok(ED25519Signature {
            r: bytes[..32]
                .try_into()
                .map_err(|_| "Invalid length for r".to_string())?,
            s: bytes[32..]
                .try_into()
                .map_err(|_| "Invalid length for s".to_string())?,
        })
    }

    fn to_secp256k1_signature(&self) -> Result<Secp256K1Signature, String> {
        let bytes = self.try_secp256k1_into_bytes()?;
        Ok(Secp256K1Signature(bytes))
    }
}


### near/utils/mod.rs ###
mod public_key_utils;
mod signature_utils;

pub use public_key_utils::*;
pub use signature_utils::*;


### near/utils/public_key_utils.rs ###
use bs58;
use std::convert::TryInto;

use crate::constants::{ED25519_PUBLIC_KEY_LENGTH, SECP256K1_PUBLIC_KEY_LENGTH};
use crate::near::types::{BlockHash, ED25519PublicKey, PublicKey, Secp256K1PublicKey};

/// Trait to extend `&str` with methods for parsing public keys and block hashes.
pub trait PublicKeyStrExt {
    /// Converts a string in base58 into a 64-byte array.
    fn to_fixed_64_bytes(&self) -> Result<[u8; 64], String>;

    /// Converts a string in base58 into a 32-byte array.
    fn to_fixed_32_bytes(&self) -> Result<[u8; 32], String>;

    /// Converts a string in base58 (with prefixes like "ed25519:" or "secp256k1:") into a `PublicKey`.
    fn to_public_key(&self) -> Result<PublicKey, String>;

    /// Converts a string in base58 (with prefixes like "ed25519:" or "secp256k1:") into a byte vector.
    fn to_public_key_as_bytes(&self) -> Result<Vec<u8>, String>;

    /// Converts a string in base58 with a "ed25519:" prefix into a 64-byte array.
    fn try_ed25519_into_bytes(&self) -> Result<[u8; ED25519_PUBLIC_KEY_LENGTH], String>;

    /// Converts a string in base58 with a "secp256k1:" prefix into a 64-byte array.
    fn try_secp256k1_into_bytes(&self) -> Result<[u8; SECP256K1_PUBLIC_KEY_LENGTH], String>;

    /// Converts a string in base58 into a 32-byte array.
    fn to_block_hash(&self) -> Result<BlockHash, String>;
}

impl PublicKeyStrExt for str {
    fn to_fixed_64_bytes(&self) -> Result<[u8; 64], String> {
        decode_base58_to_fixed_bytes::<64>(self)
    }

    fn to_fixed_32_bytes(&self) -> Result<[u8; 32], String> {
        decode_base58_to_fixed_bytes::<32>(self)
    }

    fn to_public_key(&self) -> Result<PublicKey, String> {
        let bytes = self.to_public_key_as_bytes()?;
        if self.starts_with("ed25519:") {
            Ok(PublicKey::ED25519(ED25519PublicKey(
                bytes
                    .try_into()
                    .map_err(|_| "Invalid length for ED25519 key".to_string())?,
            )))
        } else if self.starts_with("secp256k1:") {
            Ok(PublicKey::SECP256K1(Secp256K1PublicKey(
                bytes
                    .try_into()
                    .map_err(|_| "Invalid length for SECP256K1 key".to_string())?,
            )))
        } else {
            Err("Unknown key type".into())
        }
    }

    fn to_public_key_as_bytes(&self) -> Result<Vec<u8>, String> {
        let (key_type, key_data) = self
            .split_once(':')
            .ok_or_else(|| "Invalid key format".to_string())?;

        let bytes = bs58::decode(key_data)
            .into_vec()
            .map_err(|e| format!("Failed to decode base58: {}", e))?;

        match key_type {
            "ed25519" => {
                if bytes.len() == 32 {
                    Ok(bytes)
                } else {
                    Err("ED25519 public key should be 32 bytes long".to_string())
                }
            }
            "secp256k1" => {
                if bytes.len() == 64 {
                    Ok(bytes)
                } else {
                    Err("SECP256K1 public key should be 64 bytes long".to_string())
                }
            }
            _ => Err("Unknown key type".into()),
        }
    }

    fn try_ed25519_into_bytes(&self) -> Result<[u8; 32], String> {
        self.strip_prefix("ed25519:")
            .ok_or_else(|| "Invalid ED25519 key format".to_string())
            .and_then(|rest| {
                let bytes = bs58::decode(rest)
                    .into_vec()
                    .map_err(|e| format!("Failed to decode base58: {}", e))?;

                bytes
                    .try_into()
                    .map_err(|_| "Public key should be 32 bytes".to_string())
            })
    }

    fn try_secp256k1_into_bytes(&self) -> Result<[u8; 64], String> {
        self.strip_prefix("secp256k1:")
            .ok_or_else(|| "Invalid SECP256K1 key format".to_string())
            .and_then(|rest| {
                let bytes = bs58::decode(rest)
                    .into_vec()
                    .map_err(|e| format!("Failed to decode base58: {}", e))?;

                bytes
                    .try_into()
                    .map_err(|_| "Public key should be 64 bytes".to_string())
            })
    }

    fn to_block_hash(&self) -> Result<BlockHash, String> {
        decode_base58_to_fixed_bytes::<32>(self).map(BlockHash)
    }
}

/// Helper function to decode a base58 string into a fixed-size byte array.
fn decode_base58_to_fixed_bytes<const N: usize>(input: &str) -> Result<[u8; N], String> {
    bs58::decode(input)
        .into_vec()
        .map_err(|e| format!("Failed to decode base58: {}", e))
        .and_then(|bytes| {
            bytes
                .try_into()
                .map_err(|_| format!("Expected {} bytes", N))
        })
}


